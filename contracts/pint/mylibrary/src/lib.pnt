type PredicateAddress = { contract: b256, addr: b256 };

type Secp256k1Signature = { b256, b256, int };

type Secp256k1PublicKey = { b256, int };

// Helper macro for minimum function
macro @min($a, $b) {
    (
        if $a <= $b {
            $a;
        } else {
            $b;
        }
    )
}

// Helper macro for square root function using Babylonian method
macro @sqrt($y) {
    (
        if $y == 0 {
            0;
        } else if $y <= 3 {
            1;
        } else {
            var x = $y / 2 + 1;
            var result = x;
            
            while x < result {
                result = x;
                x = ($y / x + x) / 2;
            }
            
            result
        }
    )
}

// Will panic unless the pre state is nil
// and the post state is the given value.
macro @init_once($s, $v) {
    $s == nil && $s' == $v
}

// If the pre state is nil then the post state must 
// match the $eq value. 
// Otherwise the change in state must be equal to $eq.
macro @init_delta($s, $eq) {
    ($s == nil && $s' == $eq) || @delta($s) == $eq
}

// The change in state.
macro @delta($s) {
    $s' - $s
}

// The state should be initialized to 1 or incremented by 1.
macro @safe_increment($s) {
    ($s == nil && $s' == 1) || @delta($s) == 1
}

// Hash some data and then recover the public key from the signature.
// This uses the secp256k1 curve.
macro @recover($data, $sig, $key) {
    __recover_secp256k1(__sha256($data), $sig) == $key
}

// Constrain the mutable keys so nothing else can be modified.
macro @constrain_keys($key, &rest) {
    constraint __mut_keys_len() == @count($key; &rest);
    // TODO: Constrain that this key is contained in the proposed mutable set
}

// Count the number of keys in the mutable set.
macro @count($i, &rest) {
    @count(&rest) + 1
}

// Base case for the above macro.
macro @count($i) {
    1
}

// Hash the address of the current predicate.
macro @hash_this_addr() {
    __sha256({__this_contract_address(), __this_address()})
}

macro @verify_key($data, $sig, $key) {
    __sha256(__recover_secp256k1(__sha256($data), $sig)) == $key

}


macro @auth($key, $auth_for, $predicate, $allowed_predicate, &rest_allow_list) {
    @is_this_predicate($auth_for);
    constraint @check_if_predicate_owns($predicate; $key) || @check_if_predicate_in_allow_list($predicate; $allowed_predicate; &rest_allow_list);
}

macro @auth($key, $auth_for, $predicate, $allowed_predicate) {
    @is_this_predicate($auth_for);
    constraint @check_if_predicate_owns($predicate; $key) || @check_if_predicate_in_allow_list($predicate; $allowed_predicate);
}

macro @check_if_predicate_in_allow_list($predicate, $allowed_predicate, &rest_allow_list) {
    @check_if_predicate_in_allow_list($predicate; $allowed_predicate) || @check_if_predicate_in_allow_list($predicate; &rest_allow_list)
}

macro @check_if_predicate_in_allow_list($predicate, $allowed_predicate) {
    $predicate == $allowed_predicate
}

// Check if the hash of the predicate address is equal to the key.
// If so then this predicate owns the key.
macro @check_if_predicate_owns($predicate, $key) {
    __sha256($predicate) == $key
}

// Check if the authorization predicate is meant for this predicate.
macro @is_this_predicate($auth_for) {
    constraint $auth_for == { contract: __this_contract_address(), addr: __this_address() };
}
