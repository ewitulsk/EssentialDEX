use std::lib::@delta;
use std::lib::@safe_increment;
use std::lib::@init_once;
use std::lib::@init_delta;
use std::auth::@verify_key;
use std::auth::@check_if_predicate_owns;
use std::lib::Secp256k1Signature;
use std::lib::PredicateAddress;
use my_library::@min;
use my_library::@sqrt;

storage {
    reserve_usdc: int,  // Reserves for USDC
    reserve_ess: int,   // Reserves for Ess Coin
    total_supply_lp: int,  // Total LP tokens issued
    lp_balances: (b256 => int),  // LP token balances per user
    nonces: (b256 => int),  // Nonces for auth
    usdc_balances: (b256 => int),  // USDC balances per user
    ess_balances: (b256 => int),  // Ess Coin balances per user
}

union LiquidityAuth = Signed(Secp256k1Signature) | Predicate(PredicateAddress);

predicate AddLiquidity {
    pub var provider: b256;
    pub var amount_usdc: int;
    pub var amount_ess: int;

    var auth: LiquidityAuth;

    state reserve_usdc = mut storage::reserve_usdc;
    state reserve_ess = mut storage::reserve_ess;
    state provider_lp_balance = mut storage::lp_balances[provider];
    state total_supply_lp = mut storage::total_supply_lp;
    state nonce = mut storage::nonces[provider];
    state provider_usdc_balance = mut storage::usdc_balances[provider];
    state provider_ess_balance = mut storage::ess_balances[provider];

    // Calculate liquidity to mint
    const MINIMUM_LIQUIDITY: int = 1000;  

    var mint_lp = cond {
        total_supply_lp == 0 => @sqrt(amount_usdc * amount_ess) - MINIMUM_LIQUIDITY,
        else => @min((amount_usdc / (amount_usdc + reserve_usdc) * (total_supply_lp +amount_usdc) , 
                    (amount_ess / (amount_ess + reserve_ess) * (total_supply_lp +amount_ess))
    };

    // Use @delta for balance changes
    constraint @delta(reserve_usdc) == amount_usdc;
    constraint @delta(reserve_ess) == amount_ess;
    constraint @delta(total_supply_lp) == mint_lp;
    constraint @delta(provider_lp_balance) == mint_lp;
    constraint @delta(provider_usdc_balance) == 0 - amount_usdc;
    constraint @delta(provider_ess_balance) == 0 - amount_ess;

    // Increment the nonce
    constraint @safe_increment(nonce);

    // Check authorization
    constraint match auth {
        LiquidityAuth::Signed(sig) => @verify_key({provider, amount_usdc, amount_ess, nonce'}; sig; provider),
        LiquidityAuth::Predicate(addr) => @check_if_predicate_owns(addr; provider),
    };
}

predicate RemoveLiquidity {
    pub var provider: b256;
    pub var lp_amount: int;

    var auth: LiquidityAuth;

    state reserve_usdc = mut storage::reserve_usdc;
    state reserve_ess = mut storage::reserve_ess;
    state provider_lp_balance = mut storage::lp_balances[provider];
    state total_supply_lp = mut storage::total_supply_lp;
    state nonce = mut storage::nonces[provider];

    // Ensure the provider has enough LP tokens
    constraint lp_amount <= provider_lp_balance;

    // Calculate the amounts of USDC and Ess Coin to be withdrawn
    var withdraw_usdc: int = (lp_amount * reserve_usdc) / total_supply_lp;
    var withdraw_ess: int = (lp_amount * reserve_ess) / total_supply_lp;

    // Use @delta for balance changes
    constraint @delta(reserve_usdc) == 0 - withdraw_usdc;
    constraint @delta(reserve_ess) == 0 - withdraw_ess;
    constraint @delta(total_supply_lp) == 0 - lp_amount;
    constraint @delta(provider_lp_balance) == 0 - lp_amount;

    // Increment the nonce
    constraint @safe_increment(nonce);

    // Check authorization
    constraint match auth {
        LiquidityAuth::Signed(sig) => @verify_key({provider, lp_amount, nonce'}; sig; provider),
        LiquidityAuth::Predicate(addr) => @check_if_predicate_owns(addr; provider),
    };
}
